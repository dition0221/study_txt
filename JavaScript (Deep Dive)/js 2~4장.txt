2-3

AJAX (Asynchronous JavaScript and XML)
= js를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능
- 웹페이지에서 변경할 필요가 없는 부분은 렌더링하지 않고, 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 렌더링하는 방식

jQuery
- DOM(Document Object Model)을 더욱 쉽게 제어할 수 있게 됨
- 크로스 브라우징 이슈도 어느정도 해결

V8 자바스크립트 엔진
- 과거 웹 서버에서 수행되던 로직들이 대거 클라이언트(브라우저)로 이동함

Node.js
= 구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경
- 브라우저에서만 동작하던 js를 브라우저 이외의 환경에서도 동작할 수 있도록 js 엔진을 브라우저에서 독립시킨 js 실행 환경
- 서버 사이드 app 개발에 주로 사용
- 모듈, 파일 시스템, HTTP 등 내장 API를 제공
- js 엔진을 기반으로 하기에, js를 사용해 개발
- 프론트엔드와 백엔드 영역에서 js를 사용할 수 있는 장점
- 비동기 I/O를 지원, 단일 스레드(single thread) 이벤트 루프 기반으로 동작함으로써 요청(request) 처리 성능이 좋음
- 데이터를 실시간으로 처리하기 위해 I/O가 빈번하게 발생하는 SPA(Single Page Application)에 적합
- CPU 사용률이 높은 app에는 권장하지 않음

SPA 프레임워크 (Single Page Application)
- 변경에 유연하면서 확장하기 쉬운 app 아키텍처의 구축을 쉽게 만듦
- Angular, React, Vue.js, Svelte 등 다양한 SPA 프레임워크/라이브러리 사용층을 확보



2-5

자바스크립트의 특징
- HTML, CSS와 함께 웹을 구성하는 요소 중 하나
- 웹 브라우저에서 동작하는 유일한 프로그래밍 언어
- 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어
- 프로토타입 기반의 객체지향 언어



3-1

자바스크립트 실행 환경
- 브라우저와 Node.js 환경에서 동일하게 동작함
- 브라우저와 Node.js는 용도가 달라서, ECMAScript 이외에 추가로 제공하는 기능은 호환되지 않음
	- 브라우저는 웹페이지를 브라우저 화면에 렌더링하는 것이 주된 목적
	- Node.js는 브라우저 외부에서 js 실행 환경을 제공하는 것이 주된 목적



3-2

콘솔(Console)
= 브라우저의 개발자 도구(F12)의 콘솔(Console)
- js 코드에서 에러가 발생할 때 가장 우선적으로 살펴봐야 할 곳 / 열어둔 상태에서 개발하는 것이 좋음
- 디버깅을 실행하는 것 보다 간편하게 코드의 실행 결과를 확인하면서 개발하기 위해 console.log 메서드를 사용하는 경우가 많음
	- console.log( ... ) : 소괄호 안의 코드를 평가해서 그 결과를 콘솔에 출력하는 함수



3-3

npm (node package manager)
= js 패키지 매니저
- Node.js에서 사용할 수 있는 모듈들을 패키지화해서 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI를 제공

Node.js 설치
- http://nodejs.org
	- LTS(Long Term Support) 버전 : 장기적으로 안정된 지원이 보장 / 실제 개발 환경
	- Current 버전 : 최신 기능 제공 / 안정적이지 않을 수 있음 / 학습을 위함



3-4

비주얼 스튜디오
- 내장 터미널 열기 : ctrl + `
- Code Runner 확장 플러그인 : VS Code의 내장 터미널에서 단축키를 사용해 js를 비롯한 다양한 프로그래밍 언어로 구현된 소스코드를 간단히 실행 가능
	- ctrl + alt + N : js파일 실행
	- Node.js 환경을 사용해 js를 실행
	- 클라이언트 사이드 Web API가 포함된 소스코드는 Code Runner 확장 플러그인을 통해 실행하지 말고, 브라우저 환경에서 실행해야 함
- Live Server 확장 플러그인



4-1

변수 (variable)
= 하나의 값을 저장하기 위해 확보한 메모리 공간 자체
= 그 메모리 공간을 식별하기 위해 붙인 이름
= 값의 위치를 가리키는 상징적인 이름
- 할당(대입, 저장, assignment) : 변수에 값을 저장하는 것
- 참조(reference) : 변수에 저장된 값을 읽어 들이는 것



4-2

식별자 (identifier)
= 변수 이름
= 어떤 값을 구별해서 식별할 수 있는 고유한 이름
- 값이 아니라 메모리 주소를 기억하고 있음
- 변수, 함수, 클래스 등의 이름은 모두 식별자
- 네이밍 규칙을 준수해야 함
- 선언(declaeation)에 의해 js 엔진에 식별자의 존재를 알림



4-3

변수 선언
- 변수를 선언하려면 반드시 선언이 필요
- var, let, const 키워드를 사용
	ex ) var score;
- 변수에 값을 할당하지 않으면 "undefined"라는 값이 암묵적으로 할당되어 초기화 됨
- var 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행
	- 초기화(initialization) : 선언된 이후 최초로 값을 할당하는 것
	- 초기화 단계를 거치지 않으면 이전에 사용했던 값(쓰레기 값)이 남아있을 수 있음



4-4

변수 선언의 실행 시점
- 변수 선언은 소스코드가 한 줄씩 순차적으로 실행되는 시점 즉 런타임(runtime)이 아니라, 그 이전 단계에서 먼저 실행 됨
- js 엔진은 소스코드를 한 줄씩 실행하기 전, 실행 준비 단계인 소스코드의 평가 과정에서 모든 선언문들을 찾아내 먼저 실행함
	- 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행 됨

변수 호이스팅 (variable hoisting)
= 변수 선언문이 코드의 선두로 끌어 올려진 것 처럼 동작하는 js 고유의 특징
- 변수 선언 뿐만 아니라, 모든 식별자 선언은 호이스팅 됨
	- 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문



4-5

값의 할당
- 변수에 값을 할당할 때는 할당 연산자 "="를 사용
- 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 2개의 문으로 나눈 것과 동일하게 동작
	ex ) var score; score = 80;
	ex ) var score = 80;
- js 엔진에서는 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행 됨
- 변수 선언은 런타임 이전에 실행 / 값의 할당은 런타임에 실행
- 변수에 값을 할당할 때는 해당 메모리 공간에 재할당 되는게 아니라, 새로운 메모리 공간을 확보하고 그곳에 할당 됨



4-6

상수 (constant)
= 한 번 정해지면 변하지 않는 값 / 단 한 번만 할당할 수 있는 변수
- const 키워드를 사용 / 재할당 금지



4-7

식별자 네이밍 규칙
- 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있음
- 숫자로 시작하는 것은 허용하지 않음
- 예약어는 식별자로 사용 불가
- js는 대소문자를 구별하므로 각각 별개의 변수다

네이밍 컨벤션 (naming convention)
= 하나 이상의 영어 단어로 구성된 식별자를 만들 때, 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙
	- 카멜 케이스  ex ) firsetName
	- 스네이크 케이스  ex ) first_name
	- 파스칼 케이스  ex ) FirstName
	- 헝가리안 케이스  ex ) strFirstName
- 변수나 함수의 이름 - 카멜 케이스
- 생성자 함수, 클래스의 이름 - 파스칼 케이스