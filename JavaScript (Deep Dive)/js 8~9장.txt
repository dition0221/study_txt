[8 - 제어문]

제어문(control flow statement)
= 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용

블록문(block statement / compound statement) (= 코드 블록, 블록)
= 0개 이상의 문을 중괄호( {, } )로 묶은 것
- js는 블록문을 하나의 실행 단위로 취급
- 블록문은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문에, 세미콜론(;)을 붙이지 않음

조건문(conditional statement)
= 주어진 조건식(불리언 값으로 평가될 수 있는 표현식)의 평가 결과에 따라 블록문의 실행을 결정
1.  if ... else 문
	= true일 경우 if문의 코드 블록이 실행 / false일 경우 else문의 코드 블록을 실행 (논리적)
	- 조건식의 값이 불리언 값이 아니면, 암묵적으로 불리언 값으로 강제 변환됨
	= 조건식을 추가하여 조건에 따라 실행될 코드 블록을 늘리고 싶으면 'else if'문을 사용
	- else문(한 번만)과 else if문(여러 번)은 옵션
	- 코드 블록 내의 문이 하나뿐이라면, 중괄호( {, } ) 생략 가능
2.  switch 문
	= 주어진 표현식을 평가해, 그 값과 일치하는 표현식을 갖는 case문을 실행
	= case문은 상황을 의미하는 표현식을 지정하고, 콜론(:)으로 마침
		- 그 뒤에 실행할 문들을 위치시킴
	= switch문의 표현식과 일치하는 case문이 없다면 default문을 실행
		- default문은 옵션
	- 논리적 참, 거짓보다는 다양한 상황에 따라 실행할 코드 블록을 결정할 때 사용
	- 폴스루(fall through) : 실행한 switch문을 탈출하지 않고, switch문이 끝날 때까지 이후의 모든 case문과 default문을 실행하는 것
		- break문 : 코드 블록에서 탈출하는 역할
		- default문은 맨 마지막에 위치하므로, default문에는 break문을 생략하는 것이 일반적

반복문(loop statement)
= 조건식의 평가 결과가 참인 경우 코드 블록을 실행, 그 후 조건식을 다시 평가하여 여전히 참인 경우 코드 블록을 다시 실행함(조건식이 거짓일 때까지 반복)
1.  for 문
	= 조건식이 false일 때 까지 코드 블록을 반복 실행
	= for (변수 선언문 또는 할당문; 조건식; 증감식) {
		조건식이 참인 경우 반복 실행될 문;
	    }
	ex ) for (var i = 0; i < 2; i++) {
		console.log(i);
	      }
	- 반복 횟수가 명확할 때 주로 사용
2.  while 문
	= 조건식이 true이면 코드 블록을 계속해서 반복 실행 (false가 될 때 까지)
	- 반복 횟수가 불명확할 때 주로 사용
	- 무한루프에서 탈출하기 위해서는 코드 블록 내에 if문으로 탈출 조건을 만들고, break문으로 탈출
3.  do ... while 문
	= 코드 블록을 먼저 실행하고, 조건식을 평가함 (코드블록은 무조건 한 번 이상 실행됨)
	= do {
		실행 코드 블록;
	   } while (조건식);

break 문
= 코드 블록을 탈출
- 레이블 문, 반복문, switch 문의 코드 블록을 탈출함. 그 외의 코드에서 사용하면 SyntaxError(문법 에러)
	- 레이블 문(label statement) : 식별자가 붙은 문. 프로그램의 실행 순서를 제어하는 데 사용
	- 레이블 문을 탈출하려면 break 문에 레이블 식별자를 지정 ex ) break outer;
	- 레이블 문은 중첩된 for 문 외부로 탈출할 떄 유용하지만, 그 밖에 경우에는 권장하지 않음
		- 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문

continue 문
= 반복문의 코드 블록 실행을 현 지점에서 중단하고, 반복문의 증감식으로 실행 흐름을 이동시킴
- break 문처럼 반복문을 탈출하지는 않음



[9 - 타입 변환과 단축 평가]

타입 변환
= 명시적 타입 변환(타입 캐스팅) : 개발자가 의도적으로 값의 타입을 변환하는 것
= 암묵적 타입 변환(타입 강제 변환) : 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 js 엔진에의해 암묵적으로 타입이 자동 변환
- 기존 원시 값(변경 불가능한 값)을 직접 변경하는 것은 아님
- 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것

암묵적 타입 변환
1.  문자열 타입으로 변환
	= 문자열 연결 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환
	ex ) 1 + '2'  // "12"
2.  숫자 타입으로 변환
	= 산술 연산자(+ 비교 연산자)의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환
	ex ) 1 - '1'  // 0
	- 빈 문자열(' '), 빈 배열([ ]), null, false는 0으로 변환
	- true는 1로 변환
	- 객체, 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 됨
3.  불리언 타입으로 변환
	= if문, for문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 논리적으로 평가되어야 하기에 불리언 타입으로 암묵적 타입 변환
	- js 엔진은 불리언 타입이 아닌 값을 Truthy값 또는 Falsy값으로 구분함
		- Truthy값은 true로, Falsy값은 false로 암묵적 타입 변환
	- Falsy : { false, undefined, null, 0, -0, NaN, ' '(빈 문자열) }

명시적 타입 변환
- 표준 빌트인 생성자 함수(String, Number, Boolean)를 new 연산자 없이 호출하는 방법
- 빌트인 메서드를 사용하는 방법
- 암묵적 타입 변환을 이용하는 방법
1.  문자열 타입으로 변환
	1-1.  String 생성자 함수를 new 연산자 없이 호출하는 방법
		ex ) String(1);  // "1"
	1-2.  Object.prototype.toString 메서드를 사용하는 방법
		ex ) (1).toString();  // "1"
	1-3.  문자열 연결 연산자를 이용하는 방법
		ex ) 1 + '';  // "1"
2.  숫자 타입으로 변환
	2-1.  Number 생성자 함수를 new 연산자 없이 호출하는 방법
		ex ) Number('10.53');  // 10.53
		ex ) Number('true');  // 1
	2-2.  parseInt, parseFloat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능)
		ex ) parseInt('-1');  // -1
	2-3.  + 단항 산술 연산자를 이용하는 방법
		ex ) + '0';  // 0
		ex ) + 'true';  // 1
	2-4.  * 산술 연산자를 이용하는 방법
		ex ) '-1' * 1;  // -1
		ex ) true * 1;  // 1
3. 불리언 타입으로 변환
	3-1.  Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
		ex ) Boolean('x');  // true
		ex ) Boolean('');  // false
		ex ) Boolean('false');  // true
		ex ) Boolean({});  // true
		ex ) Boolean([]);  // true
	3-2.  ! 부정 논리 연산자를 두 번 사용하는 방법
		ex ) !!'x';  // true
		ex ) !!'';  // false
		ex ) !!'false';  // true
		ex ) !!{};  // true
		ex ) !![];  // true

단축 평가
1.  논리 연산자를 사용한 단축 평가
- 논리합(||) 또는 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있음
- 논리합(||) 또는 논리곱(&&) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가됨
= 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환
	- 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것
	- true || anything = true
	- false || anything = anything
	- true && anything = anything
	- false && anything = false
- 어떤 조건이 Truthy 값일 때 무언가를 해야한다면, 논리곱(&&) 연산자 표현식으로 if 문을 대체할 수 있음
- 어떤 조건이 Falsy 값일 때 무언가를 해야한다면, 논리합(||) 연산자 표현식으로 if 문을 대체할 수 있음
2.  옵셔널 체이닝 연산자
= 연산자 ?. 는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어감
	- 좌항의 피연산자가 Falsy 값(false, undefined, null, 0, -0, NaN, '')이라도 null 또는 undefined가 아니면, 우항의 프로퍼티 참조를 이어감
- 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때 유용
3.  null 변합 연산자
= 연산자 ??는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환함
- 변수에 기본값을 설정할 때 유용함
	ex ) var foo = null ?? 'default string';
	      console.log(foo);  // "default string"



[10 - 객체 리터럴]

객체(object)
- js는 객체 기반의 프로그래밍 언어이며, js를 구성하는 거의 "모든 것"이 객체
- 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체
	- 원시 값 : 변경 불가능한 값(immutable value)
	- 객체 : 변경 가능한 값(mutable value)
- 객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키(key)와 값(value)으로 구성됨
