[5 - 표현식과 문]

값(value)
= 식(표현식 expression)이 평가(evaluate)되어 생성된 결과
	- 평가 : 식을 해석해서 값을 생성하거나 참조하는 것
= 변수(variable)에 할당되는 것

리터럴(literal)
= 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법(notation)
= 값을 생성하기 위해 미리 약속한 표기법

표현식(expression)
= 값으로 평가될 수 있는 문(statement)
- 표현식이 평가되면 새로운 값을 생성하거나 기존값을 참조함
- 값으로 평가될 수 있는 문은 모두 표현식

문(statement) (=명령문)
= 프로그램을 구성하는 기본 단위이자 최소 실행 단위
- 문은 여러 토큰으로 구성됨
	- 토큰(token) : 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소
		ex ) 키워드, 식별자, 연산자, 리터럴, 세미콜론(;), 마침표(.) 등의 특수기호

세미콜론(;)
= 문의 종료를 나타냄
- 중괄호( { ... } )로 묶은 코드 블록 뒤에는 세미콜론을 붙이지 않음
	- 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문
- 문의 끝에 붙이는 세미콜론은 옵션임 (생략 가능)
	- js 엔진이 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI : Automatic Semicolon insertion)이 암묵적으로 수행되기 때문
	- 세미콜론 자동 삽입 기능의 동작과 개발자의 예측이 일치하지 않는 경우가 있음

표현식인 문과 표현식이 아닌 문
- 표현식인 문 : 값으로 평가될 수 있는 문
	ex ) 할당문 (x = 100;)
- 표현식이 아닌 문 : 값으로 평가될 수 없는 문
	ex ) 변수 선언문 (var x;)
- 구별하는 간단한 방법은 변수에 할당해 보는 것



[6 - 데이터 타입]

데이터 타입 (= 타입)
= 값의 종류
- 원시타입
	- 숫자(number) 타입 : 정수와 실수 구분없이 하나의 숫자 타입만 존재
	- 문자열(string) 타입
	- 불리언(boolean) 타입
	- undefined 타입 : var 키워드로 선언된 변수에 암묵적으로 할당되는 값
	- null 타입 : 값이 없다는 것을 의도적으로 명시할 때 사용하는 값
	- 심벌(symbol) 타입 : ES6에서 추가된 7번째 타입
- 객체 타입 : 객체, 함수, 배열 등

숫자 타입
- js는 정수와 실수 등을 구분하지 않고, 하나의 숫자 타입만 존재
- 모든 수를 실수로 처리함 (정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않음)
- { Infinity, -Infinity, NaN(산술 연산 불가; not-a-number) }도 가능
	- js는 대소문자를 구별하므로 주의할 것
	- js 엔진은 NAN, Nan, nan을 값이 아닌 식별자로 해석함 (에러 시)

문자열 타입
= 텍스트 데이터를 나타내는 데 사용
- 문자열은 작은따옴표(' '), 큰따옴표(" ") 또는 백틱(` `)으로 텍스트를 감싼다
	- 주로 작은따옴표 사용
	ex ) var string = '문자열';
	- 키워드나 식별자 같은 토큰과 구분하기 위함
- 원시 타입이며, 변경 불가능한 값(immutable value)

템플릿 리터럴(template literal)
= 새로운 문자열 표기법(ES6부터 도입)
- 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공함
- 런터인에 일반 문자열로 변환되어 처리됨
- 백틱(` `)을 사용해 표현
1. 멀티라인 문자열
- 일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않음
- 백슬래시(\)로 시작하는 이스케이프 시퀀스를 사용해 줄바꿈 등의 공백을 표현
	- \n : 개행
	- \t : 탭(수평, 들여쓰기)
- 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈 및 모든 공백도 있는 그대로 적용됨
2. 표현식 삽입
- 문자열은 +를 사용해 연결 가능
	- 피연산자 중 하나 이상이 문자열인 경우, 문자열 연결 연산자로 동작 (그 외 덧셈 연산자로 동작)
	ex ) console.log('My name is ' + first + ' ' + last + '.');
- 템플릿 리터럴 내에서는 표현식 삽입을 통해 간단히 문자열 삽입이 가능
	- ${ }으로 표현식을 감싸서 사용
	ex ) console.log(`My name is ${first} ${last}.`);
	- 표현식의 평가 결과가 문자열이 아니더라도 문자열로 타입이 강제로 변환되어 삽입됨
	ex ) console.log(`1 + 2 = ${1+2}`);  // 1 + 2 = 3

불리언 타입
- { true, false }로 2가지 값

undefined 타입
= var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화 됨
- { undefined } 값이 유일

null 타입
= 변수에 값이 없다는 것을 의도적으로 명시할 때 사용
- { null } 값이 유일

심벌(symbol) 타입
= 변경 불가능한 원시 타입 (ES6에서 추가됨)
- 심벌 값은 다른 값과 중복되지 않는 유일무이한 값
	- 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기위해 사용
- 심벌 이외의 원시 값은 리터럴을 통해 생성하지만, 심벌은 symbol 함수를 호출해 생성
	- 이 때 생성된 심벌 값은 외부에 노출되지 않음
	- 다른 값과 절대 중복되지 않는 유일무이한 값

객체 타입
- js는 객체 기반의 언어 (js를 이루고 있는 거의 모든 것이 객체)

데이터 타입의 필요성
- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

동적 타이핑
= js의 변수는 선언이 아닌 할당에 의해 타입이 결정됨
= 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있음
- js는 정적 타입 언어와 다르게, 변수를 선언할 때 타입을 선언하지 않음
	- 정적 타입 언어는 데이터 타입을 사전에 선언 해야하며, 변수 선언 시점에 변수의 타입이 결정되고 변경 불가능
	- js는 다만 var, let, const 키워드를 사용해 변수를 선언할 뿐
		- 어떠한 데이터 타입의 값이라도 자유롭게 할당 가능
- typeof 연산자로 변수의 데이터 타입을 조사할 수 있음 (변수에 할당된 값의 데이터 타입을 반환)
- 동적 타입 언어는 유연성(flexibility)은 높지만, 신뢰성(reliability)은 낮음
- 변수를 사용할 때 주의할 사항
	- 변수는 꼭 필요한 경우에 한해 제한적으로 사용
	- 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 함
	- 전역 변수는 최대한 사용 금지
	- 변수보다는 상수(const)를 사용해 값의 변경을 억제함
	- 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍 함



[7 - 연산자]

산술 연산자 (arithmetic operator)
= 수학적 계산을 수행해 새로운 숫자 값을 만듦
- 산술 연산이 불가능 할 경우, NaN을 반환
1. 이항 산술 연산자
= 2개의 피연산자를 산술 연산하여 숫자 값을 만듦
- 모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수 효과가 없음
- { +, -, *, /, % }
2. 단항 산술 연산자
= 1개의 피연산자를 산술 연산하여 숫자 값을 만듦
- { ++(증가), --(감소), +(아무 효과 없음), -(양수를 음수로, 음수를 양수로 반전) }
	- +, - : 숫자 타입이 아닌 피연산자에 사용하면, 피연산자를 숫자 타입으로 변환하여 반환
3. 문자열 연결 연산자
- '+연산자'는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작

할당 연산자
= 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당함
- { =, +=, -=, *=, /=, %= }

비교 연산자
= 좌항과 우항의 피연산자를 비교한 다음, 그 결과를 불리언 값으로 반환
- if문이나 for문 같은 제어문의 조건식에서 주로 사용
1. 동등/일치 비교 연산자
- { ==(동등 비교), ===(일치 비교), !=(부동등 비교), !==(불일치 비교) }
	- 동등 비교 : 값이 같음 (느슨한 비교)
		- 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교
		- 예측하기 어려움 / 사용 비추천
	- 일치 비교 : 값과 타입이 같음 (엄격한 비교)
		- 암묵적 타입 변환을 하지 않음
		- NaN === NaN;  // false (NaN에 주의)
			- Number.isNaN() 함수를 사용해 확인
		- 양의 0과 음의 0에 주의
			- 0 === -0;  // true
			- 0 == -0;  // true
- ES6에서 도입된 Object.is( , ) 메서드는 개선된 일치 비교 연산자(===)로 동작함
	ex ) Object.is(-0, +0);  // false
	ex ) Object.is(NaN, NaN);  // true
2. 대소 관계 비교 연산자
= 피연산자의 크기를 비교하여 불리언 값을 반환
- { >, <, >=, <= }

삼항 조건 연산자
= 조건식의 평가 결과에 따라 반환할 값을 결정
- js의 유일한 삼항 연산자
= 조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값;
	ex ) var result = x % 2 ? '홀수' : '짝수';
- 조건식의 평가 결과가 불리언 값이 아니면, 불리언 값으로 암묵적 타입 변환됨
- 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문
	- if...else문은 유사하게 처리할 수 있지만, 값처럼 사용할 수 없는 문
	ex ) var result = if (x % 2) {result = '홀수';} else {result = '짝수';};  // Error 발생

논리 연산자
- || : OR (논리합)
- && : AND (논리곱)
	- 논리합(||) 또는 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있음
	- 논리합(||) 또는 논리곱(&&) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가됨
- ! : NOT (부정)
	- 논리 부정(!) 연산자는 언제나 불리언 값을 반환
	- 피연산자가 반드시 불리언 값일 필요는 없음 (불리언 값으로 암묵적 타입 변환)
- 드 모르간의 법칙
	ex ) !(x || y) === (!x && !y)
	ex ) !(x && y) === (!x || !y)

쉼표 연산자
= 왼쪽 피연산자부터 차례대로 피연산자를 평가하고, 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환
	ex ) var x, y, z;
	x = 1, y = 2, z = 3;  // 3

그룹 연산자
- 소괄호 ( '()' )로 피연산자를 감싸는 그룹 연산자로 연산자의 우선순위를 조절 가능
- 그룹 연산자의 연산자 우선순위가 가장 높음

typeof 연산자
= 피연산자의 데이터 타입을 문자열로 반환
- { string, number, boolean, undefined, symbol, object, function } 중 하나를 반환
- 'null'을 반환하는 경우는 없음
- typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지는 않음
	- null은 object로 반환 / null은 일치 연산자(===)를 사용해 타입 확인
- 선언하지 않은 식별자는 ReferenceError가 아닌, undefined를 반환

지수 연산자
= 좌항을 밑(base)으로, 우항을 지수(exponent)로 거듭 제곱하여 숫자 값을 반환 (ES7부터 도입)
= 좌항 ** 우항
	ex ) 2 ** 3;  // 8
- 지수 연산자가 도입되기 이전에는 Math.pow 메서드를 사용했음
	ex ) Math.pow(2, 3);  // 8
- 음수를 거듭제곱의 밑(base)으로 사용하려면, 괄호로 묶어야 함
- 할당 연산자와 함께 사용 가능 ('**=')
- 이항 연산자 중에서 우선순위가 가장 높음
	ex ) 2 * 5 ** 2;  // 50

연산자의 부수 효과
- 일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있음
- { 할당 연산자(=), 증가/감소 연산자(++/--), delete 연산자 }

연산자 우선순위
1.   ( )
2.   new(매개변수 존재), ., [](프로퍼티 접근), ( )(함수 호출), ?.(옵셔널 체이닝 연산자)
3.   new(매개변수 미존재)
4.   x++, x--
5.   !x, +x, -x, ++x, --x, typeof, delete
6.   ** (이항 연산자 중에서 우선순위가 가장 높음)
7.   *, /, %
8.   +, -
9.   <, <=, >, >=, in, instanceof
10.  ==, !=, ===, !==
11.  ??(null 병합 연산자)
12.  &&
13.  ||
14.  ? ... : ...
15.  할당 연산자(=, +=, -=, ...)
16.  ,
- 연산자 우선순위가 가장 높은 그룹 연산자(소괄호)를 사용하여, 우선순위를 명시적으로 조절하는 것을 권장