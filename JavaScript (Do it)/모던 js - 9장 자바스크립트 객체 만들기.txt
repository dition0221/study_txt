9-1 객체 알아보기

객체(object)
= 프로그램에서 인식할 수 있는 모든 대상
- 데이터를 저장하고 처리하는 기본 단위
- 다양한 정보를 하나의 변수에 담아서 사용하는 자료형

사용자 정의 객체 만들기
1.. 키와 값
- 객체 생성 시 객체 이름 다음에 중괄호({})를 사용하고, 중괄호 사이에 '키 : 값' 형식으로 필요한 프로퍼티를 나열
- 객체의 키는 문자열이나 숫자, 심벌만 사용 가능
- 각 프로퍼티 사이에 쉼표(,)를 넣어 구분
ex )	객체명 {
	    키1 : 값1,
	    키2 : 값2,
	    ...
	}
2.. 객체 선언하기
- 객체 자체를 수정하는 것을 예방하기 위해 객체는 주로 const로 선언
3.. 프로퍼티 수정하고 추가하기
- 객체를 const로 지정해도 객체의 프로퍼티 값은 얼마든지 수정 가능함
4.. 빈 객체 작성 후 프로퍼티 추가하기
- 빈 객체 생성하기
	= const 객체명 = {};
	또는
	= const 객체명 = new Object();
5.. 프로퍼티 삭제하기
= delete 객체명.키;
- 키는 그대로 두고 값만 제거 할 수도 있음
	- 이 경우에는 키의 값을 'undefined'로 지정
6.. 객체 중첩하기
- 객체 안에 또 다른 객체를 넣을 수 있음 (둘 이상의 객체가 중첩)

객체의 메서드 정의하기
= 메서드 : 객체의 프로퍼티 중 객체의 동작을 지정하는 함수
- 메서드를 선언하는 방법은 일반적인 함수를 선언하는 방법과 비슷함
	= 메서드명 : function () {
		        ...
		    }
- 에크마스크립트2015에서 메서드를 정의할 때, function 이라는 예약어를 사용하지 않을 수 있음
	= 메서드명() {
	        ...
	    }
- 메서드에서 객체 안에 있는 프로퍼티 값을 사용해야 할 경우, this라는 예약어를 사용
	- 객체명 대신 this를 사용함 (객체의 메서드에서 this는 현재 객체를 가리킴)
	- 화살표 함수에서 this를 사용하면 최상위 객체인 window 객체를 가리키므로 주의

객체 복사하기
- 객체를 사용할 때 객체는 참조(by reference) 형태로 값을 전달함 (<-> 값 자체를 전달)
- 객체를 복사할 경우, 값이 아니라 값이 저장된 메모리 주소가 전달됨



9-2 생성자 함수와 클래스

- 객체마다 반복되는 프로퍼티와 메서드를 미리 정의해 놓고, 필요할 때마다 그 틀을 사용해서 객체 만들기

생성자 함수로 객체 만들기
= 생성자 함수 : 객체의 틀을 만들 때 사용하는 함수
= 인스턴스 : 생성자 함수를 사용해서 찍어내는 객체
1.. 생성자 함수 정의하기
= function 함수명(매개변수) {
       this.키1 : 값1,
       this.키2 : 값2,
	...
       this.메서드1 = function() { ... },
       this.메서드2 = function() { ... },
	...
   }
= const 함수명(매개변수) = function () {
	...
   }
- 생성자 함수 이름의 첫 글자는 항상 영문자의 대문자로 사용함
2.. new 예약어를 사용해 인스턴스 만들기
- 생성자 함수로 만든 틀을 사용해서 객체를 찍어내려면 new라는 예약어를 사용
	ex ) const book1 = new Book("웹 표준의 정석", 648, false);

클래스를 사용해 객체 만들기
- 에크마스크립트2015 이후에는 js에도 '클래스(class)'라는 개념이 도입됨
- js의 클래스는 정확한 클래스 개념이 아니라 생성자 함수를 좀 더 표현하기 쉽게 바꾼, 신택틱 슈거(syntactic sugar)
	- 신택틱 슈거(syntactic sugar) : 완전히 새로운 개념이 아니라 기존 문법을 쉽게 바꿨다는 의미
1.. 클래스 선언하기
= 클래스를 만들 때는 class 예약어 다음에 클래스명을 작성하고, 중괄호({}) 안에서 프로퍼티와 메서드를 분리해 정의
- constructor() 함수의 안에는 프로퍼티를 넣고, 밖에는 메서드를 정의함
	- constructor() 안에서 프로퍼티를 나열할 때는 쉼표(,)로 구분하지만, 메서드는 아님
- 프로퍼티의 키(key) 이름과 값(value)의 매개변수 이름이 같을 시, 변수 이름만 적는 것으로 줄여 쓰기 가능
	ex ) 'this.title = title'을 'title'로 줄여 쓰기 가능
- 메서드도 this와 function을 사용하지 않고 줄여 쓰기 가능 (간단히 메서드명과 소괄호만 사용)
	ex ) 'this.finish = function () {...}'을 'finish() {...}'로 줄여쓰기 가능
= class 클래스명 {
       constructor(매개변수) {
	프로퍼티1,
	프로퍼티2,
	...
       }
       메서드1() {...}
       메서드2() {...}
   }



9-3 객체의 키와 값에 접근하기

for...in 사용하기
= 객체의 프로퍼티에 맞는 반복문
- 객체에 어떤 프로퍼티가 있고, 또 어떤 값이 있는지 알 수 있음
- 객체의 키를 key라는 변수로 놓고, 키를 가져올 수 있음
	- 프로퍼티키에 심벌을 사용했으면, 심벌키는 건너뜀
- 프로퍼티의 값을 가져오려면 '객체명[key]'처럼 키를 사용해 따로 값을 알아내야 함
= 기본형 : for(변수 in 객체) { ... }
ex )	let bag = { type : "backpack", color : "blue", size : 15 }
	for (key in bag) { console.log(`${key}`); }  // type, color, size
	for (key in bag) { console.log(`${key} : ${bag[key]}`); }
		// type : backpack, color : blue, size : 15

Object 객체 메서드 사용하기 - keys(), values(), entries()
= Object 객체에 있는 keys(), values(), entries() 메서드를 사용하면
	키만 또는 값만 가져올 수도 있고, 키와 값을 함께 가져올 수도 있음
- 프로퍼티키에 심벌을 사용했으면 해당 프로퍼티와 값은 건너뜀
= Object.keys(객체명);  // 객체의 키만 배열로 반환
= Object.values(객체명);  // 객체의 값만 배열로 반환
= Object.entries(객체명);  // 객체의 [키, 값] 쌍을 배열로 반환



9-4 프로토타입과 클래스에서의 상속

= 상속 : 부모 객체의 프로퍼티나 메서드를 가져와서 사용하는 것
- js에서는 객체 간의 상속을 구현하기 위해 프로토타입을 사용
	- 그래서 js를 '프로토타입 기반의 언어'라고도 함

프로토타입
= 객체를 만들어 내는 원형이라고 볼 수 있고, 상위 객체 또는 부모 객체라고도 할 수 있음
- 모든 객체는 프로토타입을 가지고 있고, 프로토타입으로부터 프로퍼티와 메서드를 상속 받음
ex ) 배열 arr 변수 생성 시 arr 배열의 프로토타입은 Array 객체이고,
	arr 배열은 Array 객체의 프로퍼티와 메서드를 상속받아 사용할 수 있음.
	이 때, Array 객체를 arr 배열의 프로토타입(prototype)이라고 함.
= 프로토타입 상속 : 프로토타입인 객체에 있는 프로퍼티나 메서드를 가져와서 사용하는 것
- 객체의 프로토타입을 확인할 때는 '__proto__' 프로퍼티를 사용
	- 자신에게 연결된 부모 프로토타입 객체를 확인할 때 사용
- 생성자 함수의 프로토타입을 확인할 때는 'prototype' 프로퍼티를 사용

프로토타입 메서드
- 생성자 함수 밖에서 프로토타입을 사용해 생성자 함수의 메서드를 정의할 수도 있음
	= 객체명.prototype.함수명 = function(매개변수) { ... }
- 일반적으로 객체의 메서드는 프로토타입을 사용해서 정의

프로토타입을 상속하는 새로운 객체 만들기
- 기존의 생성자 함수에 있던 프로퍼티와 메서드를 다른 생성자 함수에서 가져와 사용(재할당)할 때
	call() 메서드를 사용하는데, 여기에서 this는 새로 만드는 객체를 가리킴
	= 기존 객체명.call(this, 프로퍼티 또는 메서드);
	- 새로 만드는 생성자 함수 안에서 정의
- 객체의 프로퍼티와 메서드를 상속받기 위해, 다른 객체를 프로토타입으로 지정하려면
	Object 객체의 setPrototypeOf() 메서드를 사용
	= Object.setPrototypeOf(하위 객체, 상위 객체);

클래스 상속
- 기존에 있던 class를 상속받아서 새 클래스를 선언할 때, extends 예약어를 사용함
	= class 새 클래스 명 extends 기존 클래스명 { ... }
	ex ) class B extends A
- 기존 클래스에 있는 프로퍼티를 사용할 때는 constructor() 함수 안에서 super() 메서드를 사용
	= super(프로퍼티);
ex ) class Textbook extends Book {
	constructor(title, price, major) {
	    super(title, price);  // 기존 클래스의 프로퍼티를 재사용
	    this.major = major;  // 새로운 프로퍼티를 정의
	}
	buyTextbook() {  // 새로운 메서드를 정의
	    console.log(`${this.major} 전공 서적, ${this.title}을 구매했습니다.`);
	}
      }