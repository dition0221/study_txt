12-1 HTTP 통신

HTTP(HyperText Transfer Protocol)
= 프로토콜(protocol) : 컴퓨터 또는 전자기기 간의 원활한 통신을 위해 지키기로 약속한 규약
= 웹에서는 'HTTP'라는 프로토콜을 사용
	= HTTP Request : 클라이언트에서 서버로 자료 요청하는 것
	= HTTP Response : 서버에서 응답해서 클라이언트로 자료를 보내는 것

요청 헤더와 응답 헤더
= 헤더(header) : 클라이언트와 서버가 요청 또는 응답으로 부가적인 정보를 전송할 수 있도록 해줌
	- 요청 헤더(request header) : 사이트 주소, 사용 중인 시스템 정보, 웹 브라우저 정보 등의 정보
	- 응답 헤더(response header) : 메시지를 보내는 시간, 메시지를 클라이언트에 어떻게 표시할지 등의 정보
- 응답 본문(response body) : 이미지나 텍스트 같은 실제 사이트 내용

요청 방식, GET과 POST
- 클라이언트에서 서버로 요청을 보낼 때 요청 헤더와 요청 본문이 함께 전송됨
	- 이 때 요청 헤더에 있는 여러 가지 정보 중에서 요청 방식을 주의해서 보아야 함
1.. GET 방식
= 서버에 자료를 요청할 때, 사이트 주소 뒤에 자료를 붙여서 보내는 방식
- GET을 사용하면 웹 브라우저의 주소 표시줄에 요청 메시지가 함께 표시되고, 따로 요청 본문은 사용하지 않음
- 서버로 사이트 주소를 보내면서 요청 자료도 함께 공개되므로, 요청 자료가 무엇인지 공개되어도 문제가 없을 경우에 사용하는 방식
ex ) 검색 창에서 검색할 때
2.. POST 방식
= 요청 내용이 겉으로 드러나지 않고 요청 본문(request body)에 따로 담아서 전송하는 방식
- 서버에 자료를 보낼 때 요청하는 방식으로, 중요한 자료를 입력하고 서버에 보낼 때 사용
ex ) 로그인하여 ID와 PW를 서버에 보낼 때

응답 상태
- 서버에서 클라이언트로 자료를 보낼 때도 응답 헤더와 본문이 함께 전송 됨
= 클라이언트에서 서버로 요청한 자료가 성공적으로 처리되었는지,
	또는 요청한 파일이 없어서 실패했는지 등의 응답 상태를 숫자로 표시한 것
- 응답 헤더 중에서 '상태' 컬럼에서 확인 가능
- 응답 상태의 주요 코드
	- 2XX : 성공
	- 4XX : 클라이언트 오류
	- 5XX : 서버 오류



12-2 JSON

JSON(JavaScript Object Notation)
= 클라이언트와 서버 간에 주고 받는 jsp 객체 표기법을 사용하는 텍스트 형식의 자료
	- 텍스트로만 구성되어 있어 서버와 클라이언트 간 주고받을 때 아주 빠르게 전송됨
	- jsp 표기법을 사용하지만, 프로그래밍 언어나 플랫폼에 대해 독립적이기 때문에 다른 언어에서도 사용 가능
	- jsp 사용자라면 읽기 쉽고, 필요에 따라 jsp 객체로도 쉽게 변환 가능
- 서버와 클라이언트 간 자료를 주고받기 위해 XML을 사용했지만, 최근에는 JSON 형식을 더 많이 사용함
- 대부분 공개 API에서도 JSON 형식을 사용함
1.. JSON의 형식
= 기본형 : {
	    "이름" : 값,
	        ...
	}
- 중괄호({}) 사이에 '이름'과 '값'으로 구성됨
- 객체에서는 '키' 부분에 큰따옴표("")가 붙지 않지만, JSON에서는 '이름' 부분에 반드시 큰따옴표를 붙여야 함
	ex ) {
	        "name" : "도레미",
	        "major" : "컴퓨터 공학",
	        "grade" : 2
	      }
- JSON 문자열 : 실제로 프로그램에서 인식하는 JSON은 다음과 같이 하나의 문자열
	ex ) '{ "name" : "도레미", "major" : "컴퓨터 공학", "grade" : 2 }'
- JSON의 '값'에는 숫자, 문자열, Boolean, null, 배열만 사용 가능 / 함수는 사용 불가
2.. JSON의 이름
- JSON 자료의 '이름' 부분은 반드시 큰따옴표("")로 묶어야 함
	- '이름'에 작은따옴표('')나 큰따옴표가 없는 이름은 사용 불가
- JSON의 이름에는 공백(space)이나 하이픈(-), 언더바(_)를 사용 가능
	- 하지만, 권장하지 않음
	- 둘 이상의 단어로 된 이름을 사용한다면, 언더바(_)를 사용하는 것이 좋음
3.. JSON의 값
- JSON의 '값'에는 숫자, 문자열, Boolean, null, 배열만 사용 가능 / 함수는 사용 불가
	- 숫자형 : 정수와 실수 모두 사용 가능 / 8진수ㅏ 16진수 표기법은 사용 불가
	- 문자열 : 항상 큰따옴표("")로 묶어야 함
	- 논리값과 null : true, false, null 사용 가능
	- 문자열, 배열 : 사용 가능 / 배열 사용 시 일반 배열과 마찬가지로 대괄호([])를 사용
- JSON 문자열 안에 또 다른 JSON 문자열을 지정할 수 있음
	ex ) {
	        "name" : "도레미",
	        "major" : "컴퓨터 공학",
	        "grade" : 2,
	        "course" : {
	          "title" : "웹 기초",
	          "timePerWeek" : 3
	        }
	      }
- 더미 JSON 정보 사이트 [ jsonplaceholder.typicode.com/users ]

객체를 JSON 자료로 변환하기 - JSON.stringify() 함수
- jsp 프로그램에서 만든 객체를 JSON 형식을 요구하는 서버로 자료를 보내야 할 경우에는 객체 형식을 JSON 형식으로 변환해야 함
= 직렬화(stringfy) : 객체를 JSON 문자열로 변환하는 것
	= 기본형 : JSON.stringfy(객체)
ex ) let student = { name : "도레미", major : "컴퓨터 공학", grade : 2 }
      let student_json = JSON.stringify(student)

JSON 문자열을 객체로 변환하기 - JSON.parse() 함수
- 서버에서 가져온 JSON 문자열을 jsp 프로그램에서 사용하려면, 객체로 변환해야 함
= 파싱(parsing) : JSON 문자열을 jsp 객체로 변환하는 것
	= 기본형 : JSON.parse(JSON 문자열)
ex ) let member = '{ "name" : "백두산", "age" : 30, "hobby" : "swimming" }'
      let member_obj = JSON.parse(member)



12-3 서버에서 자료 가져오기

AJAX(Asynchronous Javascript And XML)
= 페이지 전체를 다시 가져오지(reload) 않고도 사용자의 이벤트에 따라
	언제든지 웹 페이지의 일부만 최신 내용으로 표시할 수 있는 '비동기' 기법
	- [A] 비동기 : '동시에 일어나지 않는다'는 뜻
		- 서버에 자료를 나누어 요청하고, 요청한 자료가 도착하는 동안 다른 작업을 하는 것
	- [J] jsp : 웹 이벤트를 처리하거나, 서버로 바뀐 내용을 요청할 때 사용
		- 또한 웹 페이지에서 어떤 부분에 AJAX 기법을 적용해야 하는지 결정할 때도 jsp를 사용
	- [X] XML : 초창기 jsp에는 서버로 보낼 수 있는 자료 형식이 XML뿐 이었음
		- 지금은 XML 이외에도 일반 text, HTML, JSON 등 다양함
= XMLHttpRequest : 비동기 통신을 위해 서버와 클라이언트 사이에 주고받은 통신 기법

XMLHttpRequest 객체 만들기
= 서버에 데이터를 요청하고, 서버에서 자료를 받아올 때 HTTP 통신을 위해 사용하는 객체
	- XMLHttpRequest 객체의 프로퍼티와 메서드를 사용해서, 자료를 주고받거나 상대를 체크함
	- 웹 페이지 전체가 아니라 필요한 부분의 자료만 가져올 수 있음
	- XML 뿐만 아니라 JSON을 비롯해 여러 종류의 자료를 요청하고 받을 수 있음
- jsp 프로그램에서 서버와의 통신을 위해 XMLHttpRequest 객체를 사용하려면,
	가장 먼저 new 예약어를 사용해 객체의 인스턴스를 만들어야 함
	= 기본형 : new XMLHttpRequest()
	- 보통 XMLHttpRequest 객체의 인스턴스는 'xhr'이라는 이름을 많이 사용함 (다른 이름을 사용해도 됨)
		ex ) let xhr = new XMLHttpRequest()

서버로 자료 요청하기
- 서버로 자료를 요청하는 과정
	- 1) 웹 브라우저(클라이언트)에서 XMLHttpRequset 객체 만들기
	- 2) 어떤 자료를 가져올지 알려주기
	- 3) 서버로 HTTP 요청 보내기 [클라이언트 -> 서버]
	- 4) 서버에서 처리하기
	- 5) 자료 로딩하기 [서버 -> 클라이언트]
	- 6) 웹 브라우저(클라이언트)에서 응답 자료 처리하기
1.. open() 메서드 - 어떤 자료를 가져올지 지정
= 요청 초기화(requset initialize) : 서버로 자료를 요청하기 위해 XMLHttpRequest를 만들었으면
	open() 메서드를 사용해서 어떤 방식을 사용할지, 어떤 자료가 필요한지,
	그리고 비동기 처리 여부를 지정하는 과정
= 기본형 : open(방식, 자료 위치, 비동기 여부)
	- 방식 : HTTP 요청 방식을 지정 / { GET, POST } 중 하나이고, 대문자로 사용해야 함
		- GET : 서버에 있는 값을 가져올 때 사용
		- POST : 클라이언트에서 서버로 자료를 보낼 때 사용
	- 자료 위치 : 요청할 서버의 URL을 지정
	- 비동기 여부 : 비동기 요청인지, 동기 요청인지의 여부를 판단하는 항목
		- true - 비동기 / false - 동기 (따로 지정하지 않을 시 비동기로 처리)
2.. send() 메서드 - 서버로 요청 전송
= 사용자 요청을 서버로 보내는 메서드
= 기본형 : send(내용)
	- 괄호() 안에 들어가는 매개변수는 옵션
	- GET 방식 : null로 넘기거나 빈 상태로 남겨둠
	- POST 방식 : 서버로 넘길 내용을 매개변수로 넘겨줌
ex ) // GET 방식을 이용해 test.txt 파일에 비동기 방식으로 연결하려면
      xhr.open("GET", "test.txt", true);
      xhr.send();

JSON 파일 요청하기
- JSON 자료는 기본적으로 서버에 저장되어 있어서, 클라이언트 요청에 따라 주고받게 됨
- 연습을 위해 사용자 컴퓨터를 서버로 만들어 주는 VS Code의 '라이브 서버'를 사용
ex ) let xhr = new XMLHttpRequest();
      xhr.open("GET", "student.json");
      xhr.send();
1.. readyState 프로퍼티
= XMLHttpRequest 객체의 현재 상태를 나타냄
	- 0 상태 : 아직 아무 요청도 하지 않은 상태
	- 1 상태 : 서버로 자료를 요청하고 성공한 상태
	- 2 상태 : 서버 요청에 대한 응답으로 헤더가 도착한 상태
	- 3 상태 : 서버에서 자료들이 로딩 중인 상태
	- 4 상태 : 자료 처리가 끝나서 프로그램에서 사용할 수 있는 상태
	- 상태는 0 -> 1 -> 2 -> 3 -> 4 -> 0 -> 1 ...처럼 순서대로 반복함
2.. status, statusText 프로퍼티
= status 프로퍼티 : HTTP 상태 코드를 나타냄
	- 2XX : 성공
	- 4XX : 클라이언트 오류
	- 5XX : 서버 오류
= statusText 프로퍼티 : 상태에 대한 설명 메시지를 알려줌
3.. readystatechange 이벤트
= readyState 값이 바뀔 때 마다 발생하는 이벤트
	= onreadystatechange() 메서드를 사용
- 이 이벤트를 사용해서 상태에 따라 필요한 명령을 처리할 수 있음
	- 서버에 없는 파일을 요청해도 일단 요청은 성공했으므로 readyState 값은 4임
	- readyState 프로퍼티가 4이면서 status 프로퍼티가 200일 경우에만, 서버에서 제대로 자료를 가져온 상태
	ex ) // 서버에서 자료를 가져와 사용할 수 있는 상태인지 확인하기 위해
	      xhr.onreadystatechange = function() {
	        if (xhr.readyState == 4 && xhr.status == 200) {
	          ......
	        }
	      }
4.. responseText 프로퍼티
= 서버에서 받은 자료를 텍스트 형태로 보여주는 프로퍼티
	- response 프로퍼티도 사용 가능
- 이 JSON 문자열을 객체로 바꾸어야 프로그램에서 사용할 수 있으므로, JSON.parse()를 사용해 파싱함
	ex ) let student = JSON.parse(xhr.responseText);



12-4 예외 처리하기

예외 처리(= 에러 핸들링(error handling), 오류 처리)
= 프로그램에서 문제가 발생하면 프로그램은 실행을 멈추므로,
	소스를 작성할 때부터 발생할 만한 문제를 미리 고려하고 대비하는 작업
- 예외(exception) : 소스를 작성할 때 문법적인 실수로 발생하는 오류를 가리키기도 하고,
	프로그램의 작성 의도와 다르게 프로그램을 사용했을 때도 발생함
- 스크립트 소스에서 오류가 발생하면, 그 다음에 오는 소스는 아예 실행되지 않음

try 문, catch 문, finally 문
= 기본형 : try {
	    // 실행할 코드
	} catch(error) {
	    // try 블록에서 예외가 발생했을 때 실행할 코드
	} finally {
	    // try 블록 이후에 실행할 코드. 예외와 상관없이 실행 됨
	}
= try 문 : 실행할 명령을 작성
= catch 문 : 예외를 어떻게 처리할지 작성
	- try 블록 안에서 발생한 예외를 잡아내서(catch) 처리
	- error 객체를 인자로 받는데, error 객체에는 오류 이름과 오류 설명이 들어있음
= finally 문 : 예외가 발생하든 발생하지 않든 상관없이 try 블록 다음에 실행할 명령을 작성
	- 일반적으로 생략되는 경우가 많음
ex ) try {
        console.log("시작");
        add();
        console.log("실행 중...");
      } catch(err) {
        console.log(`오류 발생 : ${err}`);
      }
      console.log("끝");
      // 시작
      // 오류 발생 : ReferenceError: add is not defined
      // 끝
- try 블록 안에 있는 명령을 실행하다가 오류가 발생하면, try 블록에서 오류 이후의 명령은 실행되지 않음
	- catch 문으로 넘겨서 오류를 처리함
	- 예외 처리(catch 문)가 끝나면 되돌아와서 finally 블록의 명령을 실행 함

오류 표시하기
1.. console.error() 문으로 오류 메시지 표시하기
= 콘솔 창에 오류 메시지를 표시할 때는 console.error() 문을 사용하는 것이 좋음
	- 오류 발생 시 빨간색으로 표시되므로, 일반 메시지와 구별되기 때문
2.. error 객체 살펴보기
- catch 문에서 인수로 받는 error 객체를 그대로 표시하면, 오류의 이름과 오류 메시지가 모두 표시됨
	- error.name : 오류의 이름
	- error.message : 오류 메시지

throw 문
- try-catch 문은 예외가 발생했을 때 error 객체에 담겨 있는 이름이나 메시지를 사용했지만,
	사용자가 직접 예외를 만들 수도 있음
= throw 문은 jsp에서 사용자가 직접 예외를 만들면서 오류 메시지도 지정함
	= 기본형 : throw 메시지
ex ) let json = '{"grade" : 3, "age" : 25}';
      try {
        let user = JSON.parse(json);
        if (!user.name) {
          throw "사용자 이름이 없습니다.";
        }
      } catch (err) {
        console.error(err);
      }
      // 사용자 이름이 없습니다.
- thorw 문으로 오류 메시지를 만들 때 Error 객체를 사용할 수 있음
	= 기본형 : throw new Error(메시지)
	ex ) throw new Error("사용자 이름이 없습니다.");
	      // Error: 사용자 이름이 없습니다.
	- catch 블록에서 받는 Error 객체의 name은 'Error'가 되고, message는 소괄호 안의 내용이 됨